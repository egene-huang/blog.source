---
title: 接java基础
date: 2016-11-21 23:48:59
updated:
categories: Java
permalink:
tags:
- java
- javase
---

继续[java基础](https://egene-huang.github.io/2016/11/17/java-se/),　
在`Hexo`上使用`Markdown`书写格式上好像还有些问题，只好将`java 基础分为多个部分`, 希望以后能找到解决的办法.

<!-- more -->
### 运算符 ###
#### 逻辑运算符 ####

[ & ]:  逻辑运算的时候会判断所有表达式的值，其结果是，如果有一个为false 则结果为false。
[ | ]:  逻辑运算的时候会判断所有表达式的值，其结果是，如果有一个为true 则结果为true。
[ && ]:  称为短路与，其运算规则为：如果遇到一个false 值，则不再计算之后的表达式的值，返回其结果为false。

短路与的意义可以用一下程序片段解释：

```java
//
int n =12;
if (n < 0 && n/0> 2){
	System.out.println("满足条件.");
}
```

显然这段程序不会出错，因为地一个表达式值为false,则不会再判断之后的表达式。也就不会出错。

[ || ]: 也称为短路或，其运算规则为： 如果遇到一个true值，则不再计算之后的表达式的值，返回其结果为true。


#### 位运算 ####
[ & ]:  在位运算中，规则为：其中一个为`0`则结果就为`0`,  两个都为`1` 结果才为`1`。
[ | ]:    在位运算中， 规则为：其中一个为`1`则结果就为`1`,两个都为`0` 结果才为`0`。
如:
```java
// & 
    10010
&
    10011
-------------
    10010

```
```java

// |
  10010
|
  10011
-----------
  10011

```

#### 三目运算符 ####
三目运算格式为： 类型 变量 = 逻辑表达式 ? 值1 : 值2;
> 
解释：
当逻辑表达式的值为`true`时 则将值1赋值给变量。否则将值2赋值给变量。

此多运用于简单的`if ...else .....` 判断。简化代码。 但是不可以滥用。


### 程序结构 ###
#### 顺序结构 ####
按照代码编写顺序执行。

#### 分支结构 ####
可以直接理解为 `if`判断 或者多个`if` 或者`if ... else .... ` 或者`if ...else  if ... else ... .....`等等.

> 这里需要重视的是分支结构里当有重叠条件匹配时，只会进入首次匹配条件，不会再进入第二次匹配上的条件。

#### 循环结构 ####
使用`while` 、`do ...while` 、`for` 来控制代码执行顺序的代码结构。

> 这里我们可以使用`break` 、`continue` 加标签的形式控制多层循环。代码实例如下：

```java

outer:
for(int i=0;i<10;i++){
	inner:
	for(int y=0;y<8;y++){
		for(int n=0;n<5;n++){
			if(n ==3 ){
				continue outer;
			}else if(n==4){
				break inner;
			}
		}
	}
}
```
> 以上代码顺序执行解释如： 当n 为3时 则从最外层的下一次循环开始执行。则i值为1的这次循环。
> 当n 为4时，则跳出y变量所在for循环进入i 变量所在for循环的下一次循环。       


#### 多分支结构 ####

switch 语句用于多分支结构，使用基本类型值匹配条件，执行语句，避免编写复杂的`if...else ....` 使代码更易维护和查看。
格式为：
```java
switch(值){
	case v1: [代码块;]
	[break];
	case v2: [代码块;]
	[break];
	......
	default:代码块;
}

```

以上 `[] `里面的内容代表可选。我们可以不用做任何操作，语法上是允许的。
1. 假如我们没有在没一个匹配上的`case` 之后加上`break` 组织程序继续执行，则程序会在首个匹配上的`case`之后继续执行之后的所有`case`. 导致得到你预想之外的结果; 

2. 假如程序没有匹配上任何一个`case` 如果有编写`default`语句，则自动执行`default` 代码块，如果没有则走完所有`case`后退出`switch`。

关于`for'`和`while` 使用上的选择：  一般，我们在知道循环次数的时候首先选择 ‘for' 控制循环，在不知道循环次数，但是知道循环结束条件的时候考虑使用`while`类循环，

### 方法 ###
#### 方法的重载 ####
平时我们可能需要某一类的功能，区别只是参数类型或者个数有所区别，那么我们可以考虑方法的重载，不用编写多个方法。例如： 我们需求如下：
1. 需要两个int 型数据相加的方法;
2.  需要三个int 型数据相加的方法;
3.  需要两个double型数据相加的方法;

以上需求我们实现最原始的方式是给三个方法取三个不同的方法名以适应以上三个需求。假如我们考虑重载(Overload) 则只需要同一个方法名，不同参数就可以了，如下：


```java
public int add(int x,int y){
	return x + y;
}

public int add(int x,int y,int z){
	return x + y + z;
}

public double add(double x,double y){
	return x + y;
}
```


> 以上为方法重载，在我们调用的时候直接调用`add(..)` 即可，不用如此调用`add1(...)` / `add2(..)`
> 以上使用了不同的返回值类型，我们一般在编写重载方法的时候不建议编写返回值类型不同的重载方法。虽然jdk没有如此强调。重载方法统一返回类型，有利用使用。


### String 一些事儿 ###

String 不是基本数据类型。String 是一个特殊的类。首先我们实例化对象有以下两种方式：
1. 直接赋值实例化
	String str = "字符串"; 
2. 使用`new` 实例化Stirng对象
	String str = new ("字符串");  这种实例化方式在内存分配上有如下问题：
	首先，在堆内存中会分配一块内存存放匿名字符串对象 --- "字符串"。然后，关键字`new` 再次堆内存再一次分配内存给"字符串"; 然后使用`str` 引用指向刚才分配的堆内存。
	至此开始分配的内存成为垃圾资源，等待GC回收。
需要注意String 字符比较中的`==` 和`equlas`。前者是比较字符串内存地址，是数值比较，后者比较字符内容。
关于字符比较注意点： 我们使用`equlas`比较字符串的时候应该避免未实例化对象调用方法。应该将未知字符对象作为参数使用。如：不应该 这样：

```java
String var = "hello";
if(var.equlas("hello")){
	//
}
```

查询[JavaSE API](http://docs.oracle.com/javase/7/docs/api/) 找到　`java.lang # String` 可以根据需要找到对应api方法描述 -　如 字符串查找[#indexOf(String str)]／字符串截取[#substring(int beginIndex)] / 拆分等等

### 类与对象 ###
面向对象有显著的三大特征：
1. 封装
2. 继承
3. 多态

#### 封装 ####

简单的来说就是内部实现对外不可见。常用的就是我们在简单java 类中经常使用private 修饰属性权限。这就是封装的典型使用。这样我们就不能在非本类中直接操作类信息，需要通过类对象操作类属性。
类实例化两种方式：
```java
//声明并实例化对象
类型名称 对象名称 = new 类型名称();
//声明对象 ; 实例化对象
 类型名称 对象名称;
对象名称 = new 类型名称();
```
 
在java中对内存分配有`栈`和`堆`之分。 栈 存储基本类型数据和引用类型数据变量。堆存储引用类型数据内容。引用类型数据操作都存在内存关系处理。需要谨慎。
比如，现在有一个类A 则以下表达式内存关系解释：
`A a ;`  在栈内存块中，声明一个变量`a` 没有任何指向，也可以认为`a`现在指向`null` 。
`a = new A();`  在堆内存块中开辟一块内存空间，内容为`A`中属性的初始值。并将`a`指向它。

 简单java类的编写：
 + 属性全部使用 private 封装。
 + 属性必须有setter & getter方法。
 + 构造方法安装参数升序编写，必须有至少一个无参构造。
 + 保留一个能输出本类全部信息的方法。

### this/super关键字 ###

`this` 和`super`的区别:
- 使用this 操作属性或方法，优先从本类查找，否则再从父类查找。
this 可以构造方法互调用，但是必须留一个出口否则形成循环调用,必须放在构造方法的首行。this 指当前对象。

- super 存在继承关系中，指子类直接操作父类属性或方法。
	在实例化子类对象的时候必须先实例化其父类，默认会调用父类无参构造. `super();` 必须放在构造方法的首行。

